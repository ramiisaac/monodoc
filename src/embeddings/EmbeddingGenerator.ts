import { Node, SourceFile } from 'ts-morph';
import { logger } from '../utils/logger';
import { GeneratorConfig, EmbeddedNode, JSDocableNode, AIModelConfig, NodeContext } from '../types';
import { EmbeddingError } from '../utils/errorHandling'; // Removed LLMError, as it's not directly thrown here
import { AIClient } from '../generator/AIClient';
import { NodeContextExtractor } from '../generator/NodeContextExtractor';
import path from 'path';

/**
 * Responsible for generating embeddings for TypeScript nodes using the configured AI model.
 * Embeddings are vector representations of code that can be used for similarity search.
 * This class now leverages NodeContextExtractor for richer text content for embeddings.
 */
export class EmbeddingGenerator {
  private aiClient: AIClient;
  private config: GeneratorConfig;
  private baseDir: string;
  private embeddingModelConfig: AIModelConfig;
  private nodeContextExtractor: NodeContextExtractor; // Injected dependency

  constructor(
    aiClient: AIClient,
    config: GeneratorConfig,
    baseDir: string,
    nodeContextExtractor: NodeContextExtractor, // Inject NodeContextExtractor
  ) {
    this.aiClient = aiClient;
    this.config = config;
    this.baseDir = baseDir;
    this.nodeContextExtractor = nodeContextExtractor; // Assign injected extractor

    const embeddingModel = config.aiModels.find(
      (m) => m.id === config.embeddingConfig.modelId && m.type === 'embedding',
    );
    if (!embeddingModel) {
      throw new EmbeddingError(
        `Embedding model with ID '${config.embeddingConfig.modelId}' not found or not configured as an embedding model. Check your 'aiModels' config.`,
      );
    }
    this.embeddingModelConfig = embeddingModel;

    logger.success(
      `🧠 Embedding Generator initialized with model: ${this.embeddingModelConfig.model} (Provider: ${this.embeddingModelConfig.provider})`,
    );
  }

  /**
   * Generates embeddings for a list of JSDocable nodes.
   * It processes nodes in batches, leveraging NodeContextExtractor for content.
   * Properly tracks and logs batch-level failures.
   * @param nodes The JSDocableNodes for which to generate embeddings.
   * @param sourceFileMap A map from file path to SourceFile for context extraction.
   * @returns A Promise resolving to an array of EmbeddedNode objects.
   * @throws EmbeddingError if embedding generation fails critically (e.g., all batches fail).
   */
  async generateEmbeddings(
    nodes: JSDocableNode[],
    sourceFileMap: Map<string, SourceFile>,
  ): Promise<EmbeddedNode[]> {
    logger.info(`✨ Generating embeddings for ${nodes.length} nodes...`);
    const embeddedNodes: EmbeddedNode[] = [];
    const batchSize = this.config.embeddingConfig.embeddingBatchSize;
    let successfulBatches = 0;
    let failedBatches = 0;

    if (nodes.length === 0) {
      logger.info('No nodes to generate embeddings for.');
      return [];
    }

    // Process nodes in batches
    for (let i = 0; i < nodes.length; i += batchSize) {
      const batch = nodes.slice(i, i + batchSize);
      const textsToEmbed: {
        id: string;
        text: string;
        node: JSDocableNode;
        nodeContext: NodeContext;
      }[] = [];

      for (const node of batch) {
        const sourceFile = sourceFileMap.get(node.getSourceFile().getFilePath());
        if (!sourceFile) {
          logger.warn(
            `Could not find SourceFile for node ${this.getNodeNameForLogging(node)} at ${node.getSourceFile().getFilePath()}. Skipping embedding for this node.`,
          );
          continue;
        }

        // Get the full NodeContext for richer embedding content
        const nodeContext = this.nodeContextExtractor.getEnhancedNodeContext(node, sourceFile);
        const textContent = this.getNodeContentForEmbedding(nodeContext); // Use enriched content
        const nodeId = nodeContext.id; // Use the ID generated by NodeContextExtractor

        textsToEmbed.push({ id: nodeId, text: textContent, node, nodeContext });
      }

      if (textsToEmbed.length === 0) {
        logger.debug('  Skipping empty embedding batch.');
        continue;
      }

      try {
        const embeddingsResult = await this.aiClient.generateEmbeddings(
          textsToEmbed.map((t) => t.text),
        );

        if (embeddingsResult.length !== textsToEmbed.length) {
          logger.error(
            `  Mismatched embedding results for batch ${Math.floor(i / batchSize) + 1}. Expected ${textsToEmbed.length}, got ${embeddingsResult.length}. Skipping this batch.`,
          );
          failedBatches++;
          continue;
        }

        for (let j = 0; j < embeddingsResult.length; j++) {
          const { id, node, text } = textsToEmbed[j];
          embeddedNodes.push({
            id: id,
            embedding: embeddingsResult[j],
            textContent: text,
            nodeName: this.getNodeNameForLogging(node),
            nodeKind: node.getKindName(),
            filePath: node.getSourceFile().getFilePath(),
            relativeFilePath: path.relative(this.baseDir, node.getSourceFile().getFilePath()),
          });
          logger.trace(`    Generated embedding for: ${this.getNodeNameForLogging(node)}`);
        }
        successfulBatches++;
      } catch (error: unknown) {
        // Catch unknown errors properly
        failedBatches++;
        logger.error(
          `  ❌ Failed to generate embeddings for batch ${Math.floor(i / batchSize) + 1} (starting with ${textsToEmbed?.[0]?.id || 'unknown'}): ${
            error instanceof Error ? error.message : String(error)
          }. Skipping this batch.`,
        );
        // Do not re-throw immediately; try to process other batches.
      }
    }

    if (successfulBatches === 0 && failedBatches > 0 && nodes.length > 0) {
      // If there were nodes to process and ALL batches failed
      throw new EmbeddingError(
        `All embedding batches failed. Embedding generation could not be completed.`,
      );
    }

    logger.success(
      `✨ Completed embedding generation for ${embeddedNodes.length} nodes. (Successful Batches: ${successfulBatches}, Failed Batches: ${failedBatches})`,
    );
    return embeddedNodes;
  }

  /**
   * Constructs rich text content for embedding from a NodeContext.
   * This ensures the embedding model gets comprehensive information about the node.
   * @param nodeContext The enriched NodeContext.
   * @returns A string representing the node's full context for embedding.
   */
  private getNodeContentForEmbedding(nodeContext: NodeContext): string {
    const {
      nodeKind,
      nodeName,
      signatureDetails,
      codeSnippet,
      fileContext,
      packageContext,
      relevantImports,
      surroundingContext,
      parameters,
      returnType,
      isAsync,
      isExported,
      accessModifier,
    } = nodeContext;

    let content = `Kind: ${nodeKind}\nName: ${nodeName}\nSignature: ${signatureDetails}\n`;
    content += `File: ${fileContext}\nPackage: ${packageContext}\n`;

    if (isExported) content += `Access: Exported\n`;
    if (isAsync) content += `Modifier: Async\n`;
    if (accessModifier) content += `Visibility: ${accessModifier}\n`;

    if (parameters && parameters.length > 0) {
      content += `Parameters: ${parameters.map((p) => `${p.name}: ${p.type}`).join(', ')}\n`;
    }
    if (returnType) {
      content += `Returns: ${returnType}\n`;
    }

    if (relevantImports && relevantImports.length > 0) {
      content += `Relevant Imports:\n${relevantImports.join('\n')}\n`;
    }

    if (surroundingContext) {
      content += `Surrounding Context:\n${surroundingContext}\n`;
    }

    // Always include the code snippet itself, truncated if necessary
    content += `Code Snippet:\n\`\`\`typescript\n${codeSnippet}\n\`\`\``;

    return content;
  }

  /**
   * Gets a user-friendly name for a TypeScript node for logging purposes.
   * @param node The ts-morph Node.
   * @returns A string representing the node's name or kind.
   */
  private getNodeNameForLogging(node: Node): string {
    const symbol = node.getSymbol();
    if (symbol) {
      return symbol.getName();
    }
    // Corrected `any` usage
    if (
      Node.hasName(node) &&
      typeof (node as { getName?: () => string | undefined }).getName === 'function'
    ) {
      const name = (node as { getName: () => string | undefined }).getName();
      return name || node.getKindName();
    }
    return node.getKindName();
  }
}
