import { Plugin, NodeContext, GeneratorConfig, ProcessingStats } from '../types';
import { logger } from '../utils/logger';
import { BasePlugin } from './BasePlugin'; // Import BasePlugin

/**
 * A plugin to enhance JSDoc generation for React components.
 * It identifies React components and extracts specific information like props and hook usage,
 * which can then be used by the `SmartDocumentationEngine` or `afterProcessing` hook.
 */
export class ReactComponentPlugin extends BasePlugin implements Plugin {
  name = 'react-component-plugin';
  version = '1.0.0';
  description = 'Enhanced JSDoc generation for React components with prop and hook analysis.';

  constructor(config: GeneratorConfig) {
    super(config);
  }

  /**
   * Initializes the plugin.
   */
  async initialize(config: GeneratorConfig): Promise<void> {
    await super.initialize(config);
    logger.info(`ðŸ”Œ Initializing React Component Plugin v${this.version}`);
  }

  /**
   * Lifecycle hook before processing a node.
   * If the node is a React component, it extracts prop types, hook usage, and component type.
   * This data is added to `nodeContext.customData`.
   * @param context The incoming NodeContext.
   * @returns The modified NodeContext.
   */
  async beforeProcessing(context: NodeContext): Promise<NodeContext> {
    if (this.isReactComponent(context)) {
      const propTypes = this.extractPropTypes(context.codeSnippet);
      const hookUsage = this.analyzeHookUsage(context.codeSnippet);
      const componentType = this.getComponentType(context.codeSnippet);

      // Add custom data that the SmartDocumentationEngine or afterProcessing hook can use
      return {
        ...context,
        customData: {
          ...context.customData, // Preserve existing custom data
          reactProps: propTypes,
          hooksUsed: hookUsage,
          componentType: componentType,
          isReactComponent: true,
        },
      };
    }
    return context;
  }

  /**
   * Lifecycle hook after AI processing.
   * If the node was identified as a React component and has `reactProps` in custom data,
   * this method appends React-specific JSDoc tags.
   * @param context The NodeContext.
   * @param result The JSDoc string generated by AI.
   * @returns The modified JSDoc string.
   */
  async afterProcessing(context: NodeContext, result: string): Promise<string> {
    if (context.customData?.isReactComponent) {
      return this.addReactSections(result, context);
    }
    return result;
  }

  /**
   * Determines if a given NodeContext corresponds to a React component.
   * Checks for JSX, React FC types, or capitalized function components.
   * @param context The NodeContext.
   * @returns True if it's a React component, false otherwise.
   */
  private isReactComponent(context: NodeContext): boolean {
    return (
      context.codeSnippet.includes('JSX.Element') ||
      context.codeSnippet.includes('React.FC') ||
      /return\s*<[A-Za-z]/.test(context.codeSnippet) || // Detects `return <Div...`
      (context.nodeKind === 'FunctionDeclaration' && context.nodeName.match(/^[A-Z]/)) || // Capitalized function components
      (context.nodeKind === 'VariableDeclaration' &&
        context.nodeName.match(/^[A-Z]/) &&
        (context.codeSnippet.includes('React.memo') || context.codeSnippet.includes('forwardRef'))) // Memoized/forwardRef components
    );
  }

  /**
   * Extracts prop names from a React component's code snippet.
   * Looks for `interface XProps { ... }` or destructuring in function parameters.
   * @param code The component's code snippet.
   * @returns An array of extracted prop names.
   */
  private extractPropTypes(code: string): string[] {
    const propNames: string[] = [];

    // 1. From interface or type alias `XProps`
    const interfaceMatch = code.match(/(interface|type)\s+(\w+Props)\s*\{([^}]+)\}/s); // `s` for dotall
    if (interfaceMatch && interfaceMatch[3]) {
      const propDefinitions = interfaceMatch[3];
      // Regex to find `propName: type;` or `propName?: type;`
      const propRegex = /(\w+)\s*[\?:-]\s*[^;,\n]+/g;
      let match: RegExpExecArray | null;
      while ((match = propRegex.exec(propDefinitions)) !== null) {
        propNames.push(match[1]);
      }
    }

    // 2. From direct destructuring in function parameters (e.g., `({ prop1, prop2 })`)
    const destructuringMatch = code.match(/function\s+\w+\s*\((?:\{\s*([^}]+)\s*\})?\s*\)/);
    if (destructuringMatch && destructuringMatch[1]) {
      const destructuredProps = destructuringMatch[1]
        .split(',')
        .map((p) => p.trim().split(':')[0].trim())
        .filter(Boolean);
      propNames.push(...destructuredProps);
    }

    return [...new Set(propNames)]; // Return unique prop names
  }

  /**
   * Analyzes a React component's code for common hook usage.
   * @param code The component's code snippet.
   * @returns An array of hook names used (e.g., 'useState', 'useEffect').
   */
  private analyzeHookUsage(code: string): string[] {
    const hooks = [
      'useState',
      'useEffect',
      'useContext',
      'useReducer',
      'useCallback',
      'useMemo',
      'useRef',
      'useImperativeHandle',
      'useLayoutEffect',
      'useDebugValue',
      'useDeferredValue',
      'useTransition',
      'useId',
      'useSyncExternalStore',
      'useInsertionEffect',
      'useFormStatus',
      'useFormState',
      'useActionState',
    ];
    const usedHooks: string[] = [];
    hooks.forEach((hook) => {
      // Regex to match `useHook(...)` or `React.useHook(...)`
      if (new RegExp(`(?:^|\\s|\\.|\\b)(?:React\\.)?${hook}\\s*\\(`, 'g').test(code)) {
        usedHooks.push(hook);
      }
    });
    return usedHooks;
  }

  /**
   * Determines the type of React component based on its code structure.
   * @param code The component's code snippet.
   * @returns A string describing the component type (e.g., 'functional', 'class', 'memoized functional').
   */
  private getComponentType(code: string): string {
    if (code.includes('React.memo') || code.includes('memo(')) return 'memoized functional';
    if (code.includes('forwardRef')) return 'forwarded-ref functional';
    if (code.includes('class') && code.includes('extends')) return 'class';
    return 'functional';
  }

  /**
   * Appends React-specific JSDoc tags to the generated documentation.
   * @param currentJsDoc The current JSDoc string.
   * @param context The NodeContext with custom React data.
   * @returns The enhanced JSDoc string.
   */
  private addReactSections(currentJsDoc: string, context: NodeContext): string {
    const { reactProps, hooksUsed, componentType } = context.customData || {};
    let enhanced = currentJsDoc;

    if (componentType && !enhanced.includes(`@component`)) {
      enhanced += `\n@component ${componentType} React component`;
    }

    // Add @props if not already present or if prop details are desired
    if (Array.isArray(reactProps) && reactProps.length > 0) {
      // A simple check to avoid adding a generic `@props` if AI already detailed them
      if (!enhanced.includes('@param props') && !enhanced.includes('@prop')) {
        enhanced += `\n@props Available props: ${reactProps.join(', ')}`;
      }
    }

    if (Array.isArray(hooksUsed) && hooksUsed.length > 0) {
      if (!enhanced.includes('@hooks')) {
        enhanced += `\n@hooks Uses React hooks: ${hooksUsed.join(', ')}`;
      }
    }

    return enhanced;
  }
}
