import { Plugin, NodeContext, GeneratorConfig, ProcessingStats } from '../types';
import { logger } from '../utils/logger';
import { BasePlugin } from './BasePlugin'; // Import BasePlugin

/**
 * A plugin to enhance documentation for API routes and endpoints.
 * It adds specific API-related JSDoc tags like `@route`, `@middleware`, `@apiSuccess`, `@apiError`.
 */
export class ApiDocumentationPlugin extends BasePlugin implements Plugin {
  name = 'api-documentation-plugin';
  version = '1.0.0';
  description =
    'Enhanced documentation for API routes and endpoints (e.g., Next.js API routes, Express handlers).';

  constructor(config: GeneratorConfig) {
    super(config);
  }

  /**
   * Initializes the plugin.
   */
  async initialize(config: GeneratorConfig): Promise<void> {
    await super.initialize(config);
    logger.info(`ðŸ”Œ Initializing API Documentation Plugin v${this.version}`);
  }

  /**
   * Lifecycle hook before processing a node.
   * Identifies if the node is an API route and extracts relevant data (HTTP method, route path, middleware).
   * This data is then added to `nodeContext.customData` for `afterProcessing` or `SmartDocumentationEngine`.
   * @param context The incoming NodeContext.
   * @returns The modified NodeContext.
   */
  async beforeProcessing(context: NodeContext): Promise<NodeContext> {
    if (this.isApiRoute(context)) {
      const httpMethod = this.extractHttpMethod(context.codeSnippet);
      const routePath = this.extractRoutePath(context.fileContext);
      const middleware = this.extractMiddleware(context.codeSnippet);

      // Add custom data that the SmartDocumentationEngine or afterProcessing hook can use
      return {
        ...context,
        customData: {
          ...context.customData, // Preserve existing custom data
          httpMethod,
          routePath,
          middleware,
          isApiRoute: true,
        },
      };
    }
    return context;
  }

  /**
   * Lifecycle hook after AI processing.
   * If the node was identified as an API route, this method appends custom API-specific JSDoc tags.
   * @param context The NodeContext.
   * @param result The JSDoc string generated by AI.
   * @returns The modified JSDoc string.
   */
  async afterProcessing(context: NodeContext, result: string): Promise<string> {
    if (context.customData?.isApiRoute) {
      return this.addApiDocumentation(result, context);
    }
    return result;
  }

  /**
   * Determines if a given NodeContext corresponds to an API route.
   * Checks file path conventions and common HTTP method function exports.
   * @param context The NodeContext.
   * @returns True if it's an API route, false otherwise.
   */
  private isApiRoute(context: NodeContext): boolean {
    return (
      context.fileContext.includes('/api/') || // Next.js, traditional API route folders
      context.fileContext.includes('/routes/') || // Common for Express/Fastify
      /export\s+(default\s+)?(async\s+)?function\s+(GET|POST|PUT|DELETE|PATCH)/.test(
        context.codeSnippet,
      ) // Direct HTTP method exports
    );
  }

  /**
   * Extracts the HTTP method from a code snippet.
   * @param code The code snippet of the API handler.
   * @returns The HTTP method (e.g., 'GET', 'POST'), or 'UNKNOWN'.
   */
  private extractHttpMethod(code: string): string {
    const methodMatch = code.match(
      /export\s+(default\s+)?(async\s+)?function\s+(GET|POST|PUT|DELETE|PATCH)/,
    );
    return methodMatch ? methodMatch[3] : 'UNKNOWN';
  }

  /**
   * Extracts the API route path from the file's path.
   * Converts dynamic segments (e.g., `[id]`) to JSDoc-style parameters (`:id`).
   * @param filePath The absolute file path of the API route.
   * @returns The extracted API route path.
   */
  private extractRoutePath(filePath: string): string {
    let route = '/unknown';
    const apiIndex = filePath.indexOf('/api/');
    const routesIndex = filePath.indexOf('/routes/');

    if (apiIndex !== -1) {
      route = filePath.substring(apiIndex + 4); // Get part after '/api/'
    } else if (routesIndex !== -1) {
      route = filePath.substring(routesIndex + 7); // Get part after '/routes/'
    }

    // Remove file extension
    route = route.replace(/\.[^/.]+$/, '');
    // Convert dynamic segments [param] to :param
    route = route.replace(/\[([^\]]+)\]/g, ':$1');

    return route;
  }

  /**
   * Infers common middleware types from the code snippet by looking for keywords.
   * @param code The code snippet of the API handler.
   * @returns An array of inferred middleware types.
   */
  private extractMiddleware(code: string): string[] {
    const middleware: string[] = [];
    if (code.includes('authenticate') || code.includes('authMiddleware'))
      middleware.push('authentication');
    if (code.includes('authorize') || code.includes('permissionMiddleware'))
      middleware.push('authorization');
    if (code.includes('validate') || code.includes('schemaValidation') || code.includes('joi'))
      middleware.push('validation');
    if (code.includes('rateLimit')) middleware.push('rate-limiting');
    if (code.includes('cors')) middleware.push('CORS');
    return [...new Set(middleware)]; // Return unique middleware
  }

  /**
   * Appends API-specific JSDoc tags to the generated documentation.
   * @param currentJsDoc The current JSDoc string.
   * @param context The NodeContext with custom API data.
   * @returns The enhanced JSDoc string.
   */
  private addApiDocumentation(currentJsDoc: string, context: NodeContext): string {
    const { httpMethod, routePath, middleware } = context.customData || {};
    let enhanced = currentJsDoc;

    if (httpMethod && routePath) {
      // Ensure these tags are not already present to avoid duplication if AI generates them
      if (!enhanced.includes(`@route ${httpMethod} ${routePath}`)) {
        enhanced += `\n@route ${httpMethod} ${routePath}`;
      }
    }
    if (middleware && middleware.length > 0) {
      if (!enhanced.includes('@middleware')) {
        // Simple check, might need regex for robustness
        enhanced += `\n@middleware ${middleware.join(', ')}`;
      }
    }

    // Standard API success/error responses
    if (!enhanced.includes('@apiSuccess')) {
      enhanced += `\n@apiSuccess {Object} response Success response object`;
    }
    if (!enhanced.includes('@apiError')) {
      enhanced += `\n@apiError {Object} error Error response with message and status code`;
    }

    // Add a cURL or fetch example
    if (httpMethod && routePath && !enhanced.includes('@example')) {
      let exampleBody = '';
      if (httpMethod === 'POST' || httpMethod === 'PUT' || httpMethod === 'PATCH') {
        exampleBody = `--header 'Content-Type: application/json' --data-raw '{
  "key": "value"
}'`;
      }
      enhanced += `\n@example
\`\`\`bash
curl -X ${httpMethod} "http://localhost:3000${routePath}" ${exampleBody}
\`\`\`
Or using fetch:
\`\`\`typescript
fetch('/api${routePath}', {
  method: '${httpMethod}',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ /* payload */ })
})
  .then(res => res.json())
  .then(data => console.log(data));
\`\`\``;
    }

    return enhanced;
  }
}
