import { Plugin, NodeContext, GeneratorConfig, ProcessingStats } from '../types';
import { logger } from '../utils/logger';

/**
 * Abstract base class for all generator plugins.
 * Provides a common structure and basic functionality for plugins,
 * including initialization, lifecycle hooks, and configuration access.
 */
export abstract class BasePlugin implements Plugin {
  abstract name: string; // Unique name of the plugin
  abstract version: string; // Version of the plugin
  abstract description: string; // Description of the plugin

  protected config: GeneratorConfig; // The generator's current configuration
  protected enabled: boolean = false; // Whether the plugin is currently enabled

  /**
   * Constructor for BasePlugin.
   * @param config The initial generator configuration.
   */
  constructor(config: GeneratorConfig) {
    this.config = config;
  }

  /**
   * Initializes the plugin. This method is called once when the plugin is loaded.
   * Plugins can override this to perform setup tasks (e.g., load external data, set up services).
   * @param config The current generator configuration.
   */
  async initialize(config: GeneratorConfig): Promise<void> {
    this.config = config; // Update config if changed since constructor call
    logger.debug(`üîå Initializing plugin: ${this.name} v${this.version}`);
  }

  /**
   * Lifecycle hook called before a node's context is processed by the AI.
   * Plugins can modify the `NodeContext` to add or alter information provided to the AI.
   * @param context The current NodeContext.
   * @returns A Promise resolving to the (potentially modified) NodeContext.
   */
  async beforeProcessing(context: NodeContext): Promise<NodeContext> {
    return context; // Default: no modification
  }

  /**
   * Lifecycle hook called after AI has generated JSDoc content but before it's applied to the file.
   * Plugins can modify the generated JSDoc string (e.g., add custom tags, reformat).
   * @param context The NodeContext that was processed.
   * @param result The JSDoc content generated by the AI (as a string).
   * @returns A Promise resolving to the (potentially modified) JSDoc string.
   */
  async afterProcessing(_context: NodeContext, result: string): Promise<string> {
    return result; // Default: no modification
  }

  /**
   * Lifecycle hook called when the entire documentation generation process is complete.
   * Plugins can use this to generate reports, perform cleanup, or log summary data.
   * @param stats The final ProcessingStats for the entire run.
   */
  async onComplete(stats: ProcessingStats): Promise<void> {
    if (this.enabled && stats.processedFiles > 0) {
      logger.debug(`Plugin ${this.name} onComplete hook executed.`);
    }
  }

  /**
   * Lifecycle hook called when an error occurs during processing.
   * Plugins can use this to log custom error messages, send notifications, or clean up.
   * @param error The error that occurred.
   * @param context Optional. The NodeContext associated with the error, if applicable.
   */
  async onError(error: Error, context?: NodeContext): Promise<void> {
    if (this.enabled) {
      logger.warn(
        `Plugin ${this.name} encountered error: ${error.message}${context ? ` for node ${context.nodeName}` : ''}`,
      );
    }
  }

  /**
   * Enables the plugin. Sets its internal `enabled` flag to true.
   */
  enable(): void {
    this.enabled = true;
    logger.info(`‚úÖ Plugin enabled: ${this.name}`);
  }

  /**
   * Disables the plugin. Sets its internal `enabled` flag to false.
   */
  disable(): void {
    this.enabled = false;
    logger.info(`‚ùå Plugin disabled: ${this.name}`);
  }

  /**
   * Checks if the plugin is currently enabled.
   * @returns True if enabled, false otherwise.
   */
  isEnabled(): boolean {
    return this.enabled;
  }

  /**
   * Retrieves a specific option from the plugin's configuration.
   * Plugin options are typically defined within the `plugins` array in `jsdoc-config.yaml`.
   * @param key The key of the option to retrieve.
   * @param defaultValue Optional. A default value to return if the option is not found.
   * @template T The expected type of the option value.
   * @returns The option value, or the default value if not found.
   */
  protected getPluginConfig<T = unknown>(key: string, defaultValue?: T): T | undefined {
    const pluginConfig = this.config.plugins?.find((p) => p.name === this.name);
    if (
      pluginConfig &&
      pluginConfig.options &&
      Object.prototype.hasOwnProperty.call(pluginConfig.options, key)
    ) {
      return pluginConfig.options[key] as T;
    }
    return defaultValue;
  }
}
